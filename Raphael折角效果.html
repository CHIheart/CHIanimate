<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<title>Examples</title>
<meta name="description" content="">
<meta name="keywords" content="">
<link href="" rel="stylesheet">
<style>
*{margin:0;padding:0;}
#Canvas{
	background-color:#ffac13;
	width:300px;
	height:300px;
	position:relative;
}

</style>
</head>
<body>
<div id="Canvas">
</div>
</body>
</html>
<script src="http://apps.bdimg.com/libs/raphael/2.1.2/raphael-min.js"></script>
<!-- <script src="http://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script> -->
<script>
var paper=Raphael("Canvas",300,300);
	//if(typeof Raphael=='undefined') return false;
	Raphael.fn.angle=function(x1,y1,x2,y2,x3,y3){
		return this.path("M0,0Z").data({
			ps:[
				[x1,y1],
				[x2,y2],
				[x3,y3]
			]
		});
	}
	Raphael.el.flipShadow=function(options,duration,easing,callback){
		var ps=this.data("ps");
		function isInt(n){return /^\d+$/.test(n);}
		if(ps===undefined || !ps.length) return;
		typeof options !="object" && (options={});
		!isInt(duration) && (duration=1000);
		!easing && (easing='>');
		!(callback instanceof Function) && (callback=function(){});
		//获取正反参数，及力点参数（另外两个点为柄点）
		var reversed= options.reversed ? Boolean(options.reversed) : false,
			original= options.original,
			paper=this.paper,
			handle1,handle2;
		(!isInt(original) || original>ps.length) && (original=0);
		switch(original)
		{
			case 0:
				handle1=1;
				handle2=2;
				break;
			case 1:
				handle1=0;
				handle2=2;
				break;
			case 2:
				handle1=0;
				handle2=1;
				break;
		}
		//计算过程
		var o=ps[original],
			h1=ps[handle1],
			h2=ps[handle2],
			sqrt=Math.sqrt,
			module=function(vec){
				return sqrt(vec[0]*vec[0] + vec[1]*vec[1]);
			},
			fix=function(n){
				return n.toFixed(2);
			},
			v_oh1=[h1[0]-o[0],h1[1]-o[1]],
			m_oh1=module(v_oh1),
			v_oh2=[h2[0]-o[0],h2[1]-o[1]],
			m_oh2=module(v_oh2),
			v_h1h2=[h2[0]-h1[0],h2[1]-h1[1]],
			m_h1h2=module(v_h1h2),
			p=(m_oh1+m_oh2+m_h1h2)/2,//海伦公式
			size=sqrt(p * (p- m_oh1)*(p- m_oh2)*(p- m_h1h2)),
			m_og=4*size/m_h1h2,
			v_og_n=[-v_h1h2[1],v_h1h2[0]],//[x,y]垂直于[-y,x]
			m_og_n=module(v_og_n),
			uv_og=[v_og_n[0]/m_og_n,v_og_n[1]/m_og_n],
			v_og_1=[uv_og[0]*m_og,uv_og[1]*m_og],
			v_og_2=[-v_og_1[0],-v_og_1[1]],
			g1=[v_og_1[0]+o[0],v_og_1[1]+o[1]],
			g2=[v_og_2[0]+o[0],v_og_2[1]+o[1]],
			v_h1g1=[g1[0]-h1[0],g1[1]-h1[1]],
			m_h1g1=module(v_h1g1),
			g=fix(m_h1g1)==fix(m_oh1) ? g1: g2,
			path_g=Raphael.format("M{0},{1}L{2},{3}L{4},{5}Z",h1[0],h1[1],h2[0],h2[1],g[0],g[1]),
			path_0=Raphael.format("M{0},{1}L{0},{1}L{0},{1}Z",o[0],o[1]),
			path_shadow=paper.path(reversed ? path_g : path_0).attr({stroke:false,fill:"rgba(255,255,255,.3)"});
		paper.path(reversed ? path_g : path_0).attr({stroke:false,fill:"rgba(0,0,0,.3)"}).animate({path: reversed ? path_0 : path_g},duration,easing,callback).onAnimation(function(a1){
			var curpath=this.attr("path"),
				d1=curpath[0],
				x1=d1[1],
				y1=d1[2],
				d2=curpath[1],
				x2=d2[1],
				y2=d2[2],
				d3=curpath[2],
				x3=d3[1],
				y3=d3[2],
				b=x1==x2;
			path_shadow.attr({path:Raphael.format("M{0},{1}L{2},{3}L{4},{5}Z",o[0],o[1],x1,y1,b?x3:x2,b?y3:y2)});
		});
	}

var angle1=paper.angle(0,0,0,40,70,0);
angle1.flipShadow({},500);

</script>